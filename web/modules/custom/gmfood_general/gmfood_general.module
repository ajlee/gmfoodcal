<?php

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Language;
use Drupal\node\Entity\NodeType;
use Drupal\Core\Link;
use Drupal\Core\Url;
use \Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use \Drupal\views\ViewExecutable;
use Drupal\Core\Database\Query\AlterableInterface;

/*
 * TODO: DOESN'T WORK AT THE MOMENT. Should prevent direct access to the event_date node
 */
function gmfood_general_node_access(EntityInterface $entity, $operation, AccountInterface $account) {
 /* kint($entity);

  \Drupal::logger('gmfood_general_node_access')->notice($entity->getEntityTypeId());
  \Drupal::logger('gmfood_general_node_access')->notice($entity->bundle());

  if ($operation == 'delete') {
    if ($entity->getEntityTypeId() == 'node' && $entity->bundle() == 'event_date') {
      return AccessResult::forbidden();
    }
  }

  return AccessResult::neutral();*/
}


/*
 * uses hook_fullcalendar_classes
 */
function gmfood_general_fullcalendar_classes($entity) {
  //kint($entity->field_calendar);
  //kint($entity->field_calendar[0]);
  //kint($entity->field_calendar[0]->entity);
  $calendar_class = '';
  $calendar_class_id = '';
  $max_length = 32;


  //kint(is_object($entity->field_calendar));

  // check the calendar field is valid
  if(isset($entity->field_calendar) && is_object($entity->field_calendar)) {
    // get transliteration service
    $tr = \Drupal::service('transliteration');
    //kint($entity->field_calendar[0]->entity->getTitle());

    // get the related calendar
    // NOTE: in the case of multiple calendars being referenced, it will pick the first one
    $calendar_title = t($entity->field_calendar[0]->entity->getTitle());

    $calendar_field = $entity->field_calendar[0]->entity->get('field_calendar_serial');
    if (!empty($calendar_field)) {
      $calendar_id = $calendar_field[0]->value;
      $calendar_class_id = 'fc-calendar-' . $calendar_id;
    }
    // kint('serial');
    // kint($calendar_id[0]->value);
    //kint($calendar_id[0]);

    // get default language
    $lang_code = \Drupal::languageManager()->getCurrentLanguage()->getId();

    // remove problematic chars
    $sanitised = $tr->transliterate($calendar_title, $lang_code, $max_length);

    // replace spaces with hypens and lower case string
    $clean_string =  preg_replace('/\-+/', '-', strtolower(preg_replace('/[^a-zA-Z0-9_-]+/', '', str_replace(' ', '-', $sanitised))));
    $calendar_class = 'fc-' . $clean_string;

  }
  // Add the entity type as a class.
  return [
    $entity->entity_type,
    $calendar_class,
    $calendar_class_id
  ];
}

/**
 * Implements hook_entity_extra_field_info().
 */
function gmfood_general_entity_extra_field_info() {
  $extra = array();

  foreach (NodeType::loadMultiple() as $bundle) {
    $extra['node'][$bundle->Id()]['display']['read_more'] = array(
      'label' => t('Read More Link'),
      'description' => t('Displays a read more link to the content'),
      'weight' => 100,
      'visible' => TRUE,
    );
  }

  return $extra;
}

function gmfood_general_node_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {
  //kint($entity->getType());
  //kint($build);
  $valid_types = [ 'event' ];
  if (in_array($entity->getType(), $valid_types)) {
    if ($display->getComponent('read_more')) {
        $url = Url::fromRoute('entity.node.canonical', array('node' => $entity->id()));
        $build['read_more_1'] = [
          '#type' => 'link',
          '#url' => $url,
          '#title' => t('Read More'),
          '#weight' => -5,
          '#attributes' => [
            'class' => 'btn btn-primary event__read-more-link'
          ],
        ];
        $build['read_more_2'] = [
          '#type' => 'link',
          '#url' => $url,
          '#title' => t('Read More'),
          '#weight' => 50,
          '#attributes' => [
            'class' => 'btn btn-primary event__read-more-link'
          ],
      ];
    }
  }
}

/*
 * Uses hook_form_alter
 * $form: Nested array of form elements that comprise the form.
 *
 * $form_state: The current state of the form. The arguments that \Drupal::formBuilder()->getForm() was originally called
 * with are available in the array $form_state->getBuildInfo()['args'].
 * $form_id: String representing the name of the form itself. Typically this is the name of the function that generated the
 * form.
 */
function gmfood_general_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {

  // check its the node_event_form
  if (in_array($form_id,['node_event_form'])){
    // check the forms have the right fields
    if (is_array($form['field_event_dates']) && is_array($form['field_event_dates']['widget']['add_more'])) {
      // change the label for the add more field
      $form['field_event_dates']['widget']['add_more']['#value'] = t('Add another date');
      // change the label for the save field
      $form['actions']['submit']['#value'] = t('Submit this Event');
    }
  }
}


/**
 * Implements hook_query_TAG_alter().
 */
function gmfood_general_query_search_node_search_alter(AlterableInterface $query) {

  $current_path = \Drupal::service('path.current')->getPath();
  $current_alias = \Drupal::service('path.alias_manager')->getAliasByPath($current_path);

  if($current_alias == '/search/events') {
    // Only show article and blogpost content in the search results.
    $query->condition('n.type', ['event'], 'IN');
    kint($query);
    //kint($query->having);
    //kint($query->fields);
    //kint($query->condition);
  }
  else if($current_alias == '/search/node') {
    // Only show article and blogpost content in the search results.
    $query->condition('n.type', ['article', 'event', 'page', 'news_link'], 'IN');
  }
  else if($current_alias == '/search/user') {
    // Only show article and blogpost content in the search results.
    // TODO: filter some users
    // by active, admin, public
    // permissions to do this limited?
  }
}
